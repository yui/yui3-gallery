<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js&#x2F;composite-image.js - Composite-Image</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.4.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.4.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1><img src="..&#x2F;assets/css/logo.png"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: undefined</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Composite.Image.html">Composite.Image</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/gallery-composite-image.html">gallery-composite-image</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
    </div>


            <div class="apidocs">
                <div id="docs-main" class="content">
                    <h1 class="file-heading">File: js&#x2F;composite-image.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function (Y) {
    &#x27;use strict&#x27;;

    &#x2F;**
     * @module gallery-composite-image
     *&#x2F;

    var _namespace = Y.namespace(&#x27;Composite&#x27;),

        _getGetAtFunction,
        _getGetPixelIndexFunction,

        _class;

    &#x2F;**
     * Image Class
     * @class Image
     * @constructor
     * @extends Base
     * @namespace Composite
     * @param {Object} config Configuration Object.
     *&#x2F;

    _class = function (config) {
        _class.superclass.constructor.call(this, config);
    };

    _class.ATTRS = {
        &#x2F;**
         * Defines the color space for the image.
         *
         * An image can have as many channels as needed.  3 or 4 channels is
         * most common.  Usually the first channel is the red color component,
         * the second is green, the third is blue, and the fourth is alpha.
         *
         * There are various ways to represent the value of a channel.
         * Values can either be stored as integers or floating-point numbers.
         * Values may be constrained within a minimum and maximum value.
         *
         * Most commonly red, green, and blue channels are represented by
         * integers between 0 and 255.  In this case the values 0, 0, 0
         * represent black and the values 255, 255, 255 represent white.
         *
         * The alpha channel is commonly stored as a floating-point value from 0
         * to 1.  1 represents a completely visible pixel while 0 is completely
         * transparent.
         *
         * Values are not required to be constrained.  For example, sometimes it
         * is interesting or useful to store colors which have brightness beyond
         * white.
         *
         * This attribute should be set to an array of objects.  This array
         * represents the channels in order.  This array should have at least
         * one element.  This should not be a sparse array.  Each object must
         * have a mode property.  The mode property must be set to either &#x27;f&#x27;
         * for floating-point values or &#x27;i&#x27; for integer values.  Each object may
         * include the optional maximum and&#x2F;or minimum properties.  Each object
         * may include the optional blackValue and&#x2F;or whiteValue properties.  If
         * undefined, blackValue will default to 0 and whiteValue will default
         * to 255 when mode is set to &#x27;i&#x27; or 1 otherwise.
         * 
         * @attribute channels
         * @default [
         *     {maximum: 255, minimum: 0, mode:&#x27;i&#x27;},
         *     {maximum: 255, minimum: 0, mode:&#x27;i&#x27;},
         *     {maximum: 255, minimum: 0, mode:&#x27;i&#x27;},
         *     {maximum: 1, minimum: 0, mode:&#x27;f&#x27;}
         * ]
         * @type Array
         * @writeOnce
         *&#x2F;
        channels: {
            value: [{
                maximum: 255,
                minimum: 0,
                mode: &#x27;i&#x27;
            }, {
                maximum: 255,
                minimum: 0,
                mode: &#x27;i&#x27;
            }, {
                maximum: 255,
                minimum: 0,
                mode: &#x27;i&#x27;
            }, {
                maximum: 1,
                minimum: 0,
                mode: &#x27;f&#x27;
            }],
            writeOnce: &#x27;initOnly&#x27;
        },
        &#x2F;**
         * Defines the pixel dimensions of the image.
         *
         * An image can have as many dimensions as needed.  2 dimensions is most
         * common.  Usually the first dimension is width and the second is
         * height.
         *
         * @attribute dimensions
         * @default [512, 512]
         * @type Array
         * @writeOnce
         *&#x2F;
        dimensions: {
            value: [
                512,
                512
            ],
            writeOnce: &#x27;initOnly&#x27;
        },
        &#x2F;**
         * Contains the number of pixels in the image.
         * @attribute pixelCount
         * @readOnly
         * @type Number
         *&#x2F;
        pixelCount: {
            readOnly: true
        }
    };

    _class.NAME = &#x27;Composite-Image&#x27;;

    Y.extend(_class, Y.Base, {
        &#x2F;**
         * Clears the image.
         * This method is chainable.
         * @method clear
         * @chainable
         *&#x2F;
        clear: function () {
            var me = this,
                pixelData = [];
            
            pixelData.length = me._pixelData.length;
            
            me._pixelData = pixelData;

            return me;
        },
        &#x2F;**
         * Returns a new identical image.
         * @method clone
         * @return {Object}
         *&#x2F;
        clone: function () {
            var me = this,
                other = new _class({
                    channels: me.get(&#x27;channels&#x27;),
                    dimensions: me.get(&#x27;dimensions&#x27;)
                });

            other._pixelData = me._pixelData.slice();

            return other;
        },
        &#x2F;**
         * Invokes a function for each pixel in the image.
         * This method is chainable.
         * @method eachPixel
         * @chainable
         * @param {Object} pixelParameters This object contains the following
         * members
         * &lt;ul&gt;
         *     &lt;li&gt;
         *         ctx - Object - Optional scope with which to call fn.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         fn - Function - This function is invoked once per pixel.
         *         This function will receive an object with the following
         *         parameters
         *         &lt;ul&gt;
         *             &lt;li&gt;
         *                 at - Array of image pixel coordinates.
         *             &lt;&#x2F;li&gt;
         *             &lt;li&gt;
         *                 chs - Array of image channel definitions.
         *             &lt;&#x2F;li&gt;
         *             &lt;li&gt;
         *                 dims - Array of image dimension lengths.
         *             &lt;&#x2F;li&gt;
         *             &lt;li&gt;
         *                 img - Reference to this image.
         *             &lt;&#x2F;li&gt;
         *             &lt;li&gt;
         *                 pch - Array of pixel channel indices.
         *             &lt;&#x2F;li&gt;
         *             &lt;li&gt;
         *                 pcnt - Number of pixels in this image.
         *             &lt;&#x2F;li&gt;
         *             &lt;li&gt;
         *                 pix - Integer index of this pixel.
         *             &lt;&#x2F;li&gt;
         *             &lt;li&gt;
         *                 pxl - Array of pixel channel values.
         *             &lt;&#x2F;li&gt;
         *         &lt;&#x2F;ul&gt;
         *         If this function returns true, eachPixel will stop and ignore
         *         the remaining pixels.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         pch - Array - Optional array of channel indexes.  If
         *         undefined, pixels will contain all channels in order.
         *     &lt;&#x2F;li&gt;
         * &lt;&#x2F;ul&gt;
         * @param {Function} callbackFunction This function is invoked after the
         * function has been invoked for each pixel in the image.  This function
         * will receive an object with the following members
         * &lt;ul&gt;
         *     &lt;li&gt;
         *         chs - Array of image channel definitions.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         dims - Array of image dimension lengths.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         img - Reference to this image.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         pcnt - Number of pixels in this image.
         *     &lt;&#x2F;li&gt;
         *     &lt;li&gt;
         *         pix - The last integer pixel index processed.  If eachPixel
         *         was not stopped early, this value should be equal to pcnt and
         *         not a valid pixel index.
         *     &lt;&#x2F;li&gt;
         * &lt;&#x2F;ul&gt;
         * @param {Object} contextObject Optional scope with which to call the
         * callback function.
         *&#x2F;
        eachPixel: function (pixelParameters, callbackFunction, contextObject) {
            var ctx = pixelParameters.ctx,
                fn = pixelParameters.fn,
                me = this,
                pixelChannels = pixelParameters.pch,
                pixelCount = me.get(&#x27;pixelCount&#x27;),
            
                channels = Y.clone(me.get(&#x27;channels&#x27;)),
                dimensions = me.get(&#x27;dimensions&#x27;).slice(),
                getAt = _getGetAtFunction.apply(me, dimensions),

                thisPixel;

            thisPixel = function (pixelIndex) {
                if (pixelIndex &gt;= pixelCount) {
                    callbackFunction.call(contextObject, {
                        chs: channels,
                        dims: dimensions,
                        img: this,
                        pcnt: pixelCount,
                        pix: pixelIndex
                    });
                    return;
                }

                Y.later(0, this, function () {
                    var at = getAt(pixelIndex),
                        me = this;

                    if (fn.call(ctx, {
                        at: at,
                        chs: channels,
                        dims: dimensions,
                        img: me,
                        pch: pixelChannels,
                        pcnt: pixelCount,
                        pix: pixelIndex,
                        pxl: me.getPixel(at, pixelChannels)
                    })) {
                        callbackFunction.call(contextObject, {
                            chs: channels,
                            dims: dimensions,
                            img: me,
                            pcnt: pixelCount,
                            pix: pixelIndex
                        });
                    } else {
                        thisPixel.call(me, pixelIndex + 1);
                    }
                });
            };

            thisPixel.call(me, 0);
            return me;
        },
        &#x2F;**
         * Converts a pixel index to an at array.
         * @method getAt
         * @param {Number} pixelIndex
         * @return {Array}
         *&#x2F;
        getAt: function (pixelIndex) {
            return _getGetAtFunction.apply(this, this.get(&#x27;dimensions&#x27;))(pixelIndex);
        },
        &#x2F;**
         * Accessor method to get a pixel from the image.
         * @method getPixel
         * @param {Array} at Array containing pixel coordinates.  The length of
         * this array should match the number of dimensions of the image.
         * @param {Array} pixelChannels Optional array of channel indexes.  If
         * undefined, returned pixel will contain all channels in order.
         * @return {Array}
         *&#x2F;
        getPixel: function (at, pixelChannels) {
            var me = this,
                pixelData = me._pixelData,
                pixelDataIndex,

                channelsLength = me.get(&#x27;channels.length&#x27;);

            pixelDataIndex = _getGetPixelIndexFunction.apply(me, me.get(&#x27;dimensions&#x27;))(at) * channelsLength;

            if (pixelChannels) {
                return (function (pixelData, pixelDataIndex) {
                    var i,
                        pixel = [],
                        pixelChannelsLength;

                    for (i = 0, pixelChannelsLength = pixelChannels.length; i &lt; pixelChannelsLength; i += 1) {
                        pixel[i] = pixelData[pixelDataIndex + pixelChannels[i]];
                    }

                    return pixel;
                }(pixelData, pixelDataIndex));
            }

            return pixelData.slice(pixelDataIndex, pixelDataIndex + channelsLength);
        },
        &#x2F;**
         * Converts an at array to a pixel index.
         * @method getPixelIndex
         * @param {Array} at
         * @return {Number}
         *&#x2F;
        getPixelIndex: function (at) {
            return _getGetPixelIndexFunction.apply(this, this.get(&#x27;dimensions&#x27;))(at);
        },
        initializer: function () {
            var me = this,

                channels = me.get(&#x27;channels&#x27;),
                dimensions = me.get(&#x27;dimensions&#x27;),
                pixelCount = 1,
                pixelData = [];

            if (!channels.length) {
                throw &#x27;Image must have at least one channel.&#x27;;
            }

            if (!dimensions.length) {
                throw &#x27;Image must have at least one dimension.&#x27;;
            }

            Y.each(channels, function (channel) {
                channel.blackValue = channel.blackValue || 0;
                channel.whiteValue = channel.whiteValue || (channel.mode === &#x27;i&#x27; ? 255 : 1);
            });

            Y.each(dimensions, function (dimension) {
                if (dimension &lt;= 0) {
                    throw &#x27;Dimension must have at least 1 pixel.&#x27;;
                }

                pixelCount *= dimension;
            });

            me._set(&#x27;pixelCount&#x27;, pixelCount);

            pixelData.length = pixelCount * channels.length;
            
            this._pixelData = pixelData;
        },
        &#x2F;**
         * Accessor method to set a pixel in the image.
         * This method is chainable.
         * @method setPixel
         * @chainable
         * @param {Array} at Array containing pixel coordinates.  The length of
         * this array should match the number of dimensions of the image.
         * @param {Array} pixel Array containing the pixel&#x27;s channel values.
         * @param {Array} pixelChannels Optional array of channel indexes.  If
         * undefined, the given pixel is assumed to contain all channels in
         * order.
         *&#x2F;
        setPixel: function (at, pixel, pixelChannels) {
            var i,
                me = this,
                pixelChannelsLength,
                pixelData = me._pixelData,
                pixelDataIndex,

                channels = me.get(&#x27;channels&#x27;),
                channelsLength = channels.length;

            pixelDataIndex = _getGetPixelIndexFunction.apply(me, me.get(&#x27;dimensions&#x27;))(at) * channelsLength;

            if (pixelChannels) {
                for (i = 0, pixelChannelsLength = pixelChannels.length; i &lt; pixelChannelsLength; i += 1) {
                    pixelData[pixelDataIndex + pixelChannels[i]] = _class.conformChannelValue(pixel[i], channels[pixelChannels[i]]);
                }
            } else {
                for (i = 0; i &lt; channelsLength; i += 1) {
                    pixelData[pixelDataIndex + i] = _class.conformChannelValue(pixel[i], channels[i]);
                }
            }

            return this;
        }
    }, {
        &#x2F;**
         * Conforms the given value to the channel&#x27;s specifications.
         * @method conformChannelValue
         * @param {Number} value
         * @param {Object} channel
         * @return {Number}
         * @static
         *&#x2F;
        conformChannelValue: function (value, channel) {
            value = +value || 0;

            if (channel.maximum) {
                value = Math.min(value, channel.maximum);
            }

            if (channel.minimum) {
                value = Math.max(value, channel.minimum);
            }

            if (channel.mode === &#x27;i&#x27;) {
                value = Math.round(value);
            }

            return value;
        }
    });

    &#x2F;**
     * Call this function with the length of each dimension followed by the
     * number of channels.  Returns a function which accepts a pixel index and
     * returns an at array.
     * @method _getGetAtFunction
     * @private
     * @return Function
     *&#x2F;
    _getGetAtFunction = Y.cached(function () {
        var dimensionLengths = arguments,
            floor = Math.floor,

            dimensionsLength = dimensionLengths.length;

        return Y.cached(function (pixelIndex) {
            var at = [
                    pixelIndex % dimensionLengths[0]
                ],
                i,
                j,
                product;

            for (i = 1; i &lt; dimensionsLength; i += 1) {
                product = 1;

                for (j = 0; j &lt; i; j += 1) {
                    product *= dimensionLengths[j];
                }

                at[i] = floor(pixelIndex &#x2F; product) % i;
            }

            return at;
        });
    });

    &#x2F;**
     * Call this function with the length of each dimension.
     * Returns a function which accepts dimension indices and returns a pixel
     * index.
     * @method _getGetPixelIndexFunction
     * @private
     * @return Function
     *&#x2F;
    _getGetPixelIndexFunction = Y.cached(function () {
        var dimensionLengths = arguments,

            dimensionsLength = dimensionLengths.length;

        return Y.cached(function () {
            var dimensionIndices = arguments,
                i,
                index = 0,
                j,
                offset;

            for (i = 0; i &lt; dimensionsLength; i += 1) {
                offset = dimensionIndices[i];

                for (j = i - 1; j &gt; 0; j -= 1) {
                    offset *= dimensionLengths[j];
                }

                index += offset;
            }

            return index;
        });
    });

    _namespace.Image = _class;
}(Y));
    </pre>
</div>

                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<!--script src="..&#x2F;assets/js/tabs.js"></script-->
<script src="..&#x2F;assets/../api.js"></script>


<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
